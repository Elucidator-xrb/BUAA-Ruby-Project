# Rails 启动流程

一个Rails应用常以运行`rails server`启动。以下分析将以rails 4.1文档为基础，结合本地rails 7.0.4实际实验。可能会和真实流程有差异，不过核心思想应该大同小异

## 一、启动rails

以下文件路径均默认为相对于`自己的Rails应用根目录`而言（若有以`~/.gem/`开头，则表示系统目录，其中`railities`为统称，本机上为`railities-7.0.4`）

### 1. ~/.gem/bin/rails

`rails server`命令中的`rails`其实就是一个Ruby可执行文件，根据环境变量，系统应该会定位到`~/.gem/bin/rails`文件（可执行，同时也是脚本），其内容为

```ruby
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

Gem.use_gemdeps

version = ">= 0.a"

str = ARGV.first
if str
  str = str.b[/\A_(.*)_\z/, 1]
  if str and Gem::Version.correct?(str)
    version = str
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
load Gem.activate_bin_path('railties', 'rails', version)
else
gem "railties", version
load Gem.bin_path("railties", "rails", version)
end
```
其中的`load Gem.activate_bin_path('railties', 'rails', version)`会载入`railties/bin/rails`（我没找到），其中包含`require "rails/cli"`，载入`cli`模块会调用`Rails::AppRailsLoader.exec_app_rails`方法，定位到我们自己Rails应用中的`bin/rails`并运行。其实相当于`exec`命令

```ruby
exec ruby bin/rails server
```

### 2. bin/rails

包含如下代码：

```ruby
#!/usr/bin/env ruby
APP_PATH = File.expand_path('../../config/application', __FILE__)
require_relative '../config/boot'
require 'rails/commands'
```

`APP_PATH`将于`rails/commands`中使用，`config/boot`用于载入Bundle并初始化配置

### 3. config/boot.rb

包含代码

```ruby
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup" # Set up gems listed in the Gemfile.
require "bootsnap/setup" # Speed up boot time by caching expensive operations.
```
第一句根据`ENV['BUNDLE_GEMFILE']`中的值来查找`Gemfile`文件的路径（一般就在根目录）。如果存在则执行`bundler/setup`，配置`Gemfile`依赖项的加载路径。

### 4. ~/.gem/gems/railties/lib/rails/commands.rb

执行完`config/boot.rb`，`bin/rails`将会加载`~/.gem/gems/railties/lib/rails/commands.rb`，该文件用于解析别名，`ARGV`数组包含的server被匹配，内容如下：

```ruby
# frozen_string_literal: true

require "rails/command"

aliases = {
  "g"  => "generate",
  "d"  => "destroy",
  "c"  => "console",
  "s"  => "server",
  "db" => "dbconsole",
  "r"  => "runner",
  "t"  => "test"
}

command = ARGV.shift
command = aliases[command] || command

Rails::Command.invoke command, ARGV
```

如果我们使用`s`缩写代替 `server`，Rails系统会从`aliases`中查找匹配的命令。

最后一行调用模块`Rails`下子模块`Command`的`invoke`方法（目录`~/.gem/gems/railties/lib/rails/command.rb`）

### 5. ~/.gem/gems/railties/lib/rails/command.rb

`Rail`模块下`Command`子模块中的`invoke`方法内容如下：

```ruby
# frozen_string_literal: true

require "active_support"
require "active_support/core_ext/enumerable"
require "active_support/core_ext/object/blank"

require "thor"

module Rails
  module Command
    extend ActiveSupport::Autoload

    autoload :Behavior
    autoload :Base

    include Behavior

    HELP_MAPPINGS = %w(-h -? --help)

    class << self
      
      # ...

      # Receives a namespace, arguments, and the behavior to invoke the command.
      def invoke(full_namespace, args = [], **config)
        namespace = full_namespace = full_namespace.to_s

        if char = namespace =~ /:(\w+)$/
          command_name, namespace = $1, namespace.slice(0, char)
        else
          command_name = namespace
        end

        command_name, namespace = "help", "help" if command_name.blank? || HELP_MAPPINGS.include?(command_name)
        command_name, namespace, args = "application", "application", ["--help"] if rails_new_with_no_path?(args)
        command_name, namespace = "version", "version" if %w( -v --version ).include?(command_name)

        original_argv = ARGV.dup
        ARGV.replace(args)

        command = find_by_namespace(namespace, command_name)
        if command && command.all_commands[command_name]
          command.perform(command_name, args, config)
        else
          args = ["--describe", full_namespace] if HELP_MAPPINGS.include?(args[0])
          find_by_namespace("rake").perform(full_namespace, args, config)
        end
      ensure
        ARGV.replace(original_argv)
      end

      # ...
    end
  end
end
```

用于处理输入的`rails xxx`命令。如若`namespace`为空则输出help界面；若命令为`rails runserver`则继续执行`Rails`模块下的另一子模块`Command`中`ServerCommand`子类的`perform`方法

### 6. ~/.gem/railties/lib/rails/commands/server/server_command.rb

`perform`方法相关内容如下：

```ruby
module Rails
    #...
    module Command
        class ServerCommand < Base # :nodoc:
    
        # ...

        def perform
            extract_environment_option_from_argument
            set_application_directory!
            prepare_restart

            Rails::Server.new(server_options).tap do |server|
            # Require application after server sets environment to propagate
            # the --environment option.
                require APP_PATH
                Dir.chdir(Rails.application.root)

                if server.serveable?
                    print_boot_information(server.server, server.served_url)
                    after_stop_callback = -> { say "Exiting" unless options[:daemon] }
                    server.start(after_stop_callback)
                else
                    say rack_server_suggestion(using)
                end
            end
        end
        
        # ...
    end
  end
end
```

### 7. 